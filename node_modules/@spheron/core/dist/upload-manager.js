"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UploadManager = void 0;
const axios_1 = __importDefault(require("axios"));
const p_limit_1 = __importDefault(require("p-limit"));
const enums_1 = require("./spheron-api/enums");
class UploadManager {
    constructor(apiUrl) {
        this.spheronApiUrl = apiUrl !== null && apiUrl !== void 0 ? apiUrl : "https://api-v2.spheron.network";
    }
    initiateUpload(configuration) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.validateUploadConfiguration(configuration);
                let url = `${this.spheronApiUrl}/v1/upload/initiate?protocol=${configuration.protocol}&bucket=${configuration.name}&maxSize=${(_a = configuration.maxSize) !== null && _a !== void 0 ? _a : ""}`;
                if (configuration.organizationId) {
                    url += `&organization=${configuration.organizationId}`;
                }
                if (configuration.createSingleUseToken) {
                    url += `&create_single_use_token=${configuration.createSingleUseToken}`;
                }
                const response = yield axios_1.default.post(url, {}, {
                    headers: {
                        Authorization: `Bearer ${configuration.token}`,
                    },
                });
                return response.data;
            }
            catch (error) {
                const errorMessage = ((_c = (_b = error === null || error === void 0 ? void 0 : error.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.message) || (error === null || error === void 0 ? void 0 : error.message);
                throw new Error(errorMessage);
            }
        });
    }
    pinCID(configuration) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!configuration.name) {
                    throw new Error("Bucket name is not provided.");
                }
                let url = `${this.spheronApiUrl}/v2/ipfs/pin/${configuration.cid}?bucket=${configuration.name}&in_background=${configuration.inBackground ? "true" : "false"}`;
                if (configuration.organizationId) {
                    url += `&organization=${configuration.organizationId}`;
                }
                const response = yield axios_1.default.post(url, {}, {
                    headers: {
                        Authorization: `Bearer ${configuration.token}`,
                    },
                });
                return response.data;
            }
            catch (error) {
                const errorMessage = ((_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.message) || (error === null || error === void 0 ? void 0 : error.message);
                throw new Error(errorMessage);
            }
        });
    }
    pinCIDs(configuration) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!configuration.name) {
                    throw new Error("Bucket name is not provided.");
                }
                let url = `${this.spheronApiUrl}/v2/ipfs/pins?bucket=${configuration.name}`;
                if (configuration.organizationId) {
                    url += `&organization=${configuration.organizationId}`;
                }
                const response = yield axios_1.default.post(url, {
                    cids: configuration.cids,
                }, {
                    headers: {
                        Authorization: `Bearer ${configuration.token}`,
                    },
                });
                return response.data;
            }
            catch (error) {
                const errorMessage = ((_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.message) || (error === null || error === void 0 ? void 0 : error.message);
                throw new Error(errorMessage);
            }
        });
    }
    getCIDStatus(CID) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!CID) {
                    throw new Error("CID is not provided.");
                }
                const url = `${this.spheronApiUrl}/v2/ipfs/pins/${CID}/status`;
                const response = yield axios_1.default.get(url);
                return response.data;
            }
            catch (error) {
                const errorMessage = ((_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.message) || (error === null || error === void 0 ? void 0 : error.message);
                throw new Error(errorMessage);
            }
        });
    }
    uploadPayloads(payloads, configuration) {
        return __awaiter(this, void 0, void 0, function* () {
            let errorMessage = "";
            const limit = (0, p_limit_1.default)(configuration.parallelUploadCount);
            const uploadPayload = (payload, uploadId) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                try {
                    if (errorMessage) {
                        return;
                    }
                    const { data } = yield axios_1.default.post(`${this.spheronApiUrl}/v1/upload/${uploadId}/data`, payload, this.getAxiosRequestConfig(configuration.token));
                    configuration.onChunkUploaded &&
                        configuration.onChunkUploaded(data.uploadSize);
                }
                catch (error) {
                    errorMessage = ((_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.message) || (error === null || error === void 0 ? void 0 : error.message);
                }
            });
            yield Promise.all(payloads.map((payload) => limit(() => uploadPayload(payload, configuration.uploadId))));
            return { success: !errorMessage, errorMessage: errorMessage };
        });
    }
    finalizeUpload(uploadId, upload, token) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield axios_1.default.post(`${this.spheronApiUrl}/v1/upload/${uploadId}/finish?action=${upload ? "UPLOAD" : "CANCEL"}`, {}, this.getAxiosRequestConfig(token));
                return response.data;
            }
            catch (error) {
                const errorMessage = ((_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.message) || (error === null || error === void 0 ? void 0 : error.message);
                throw new Error(errorMessage);
            }
        });
    }
    validateUploadConfiguration(configuration) {
        const supportedProtocols = Object.values(enums_1.ProtocolEnum);
        if (supportedProtocols.indexOf(configuration.protocol) === -1) {
            throw new Error(`Protocol '${configuration.protocol}' is not supported. Supported protocols are [${supportedProtocols.join(", ")}].`);
        }
        if (!configuration.name) {
            throw new Error("Bucket name is not provided.");
        }
    }
    getAxiosRequestConfig(token) {
        return {
            headers: {
                Authorization: `Bearer ${token}`,
            },
        };
    }
}
exports.UploadManager = UploadManager;
