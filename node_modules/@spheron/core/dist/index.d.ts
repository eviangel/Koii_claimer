import FormData from 'form-data';

declare enum ProjectTypeEnum {
    STANDARD = "STANDARD",
    UPLOAD = "UPLOAD"
}
declare enum DeploymentEnvironmentStatusEnum {
    ACTIVE = "ACTIVE",
    INACTIVE = "INACTIVE",
    PAYMENT_PENDING = "PAYMENT_PENDING"
}
declare enum ProjectStateEnum {
    MAINTAINED = "MAINTAINED",
    ARCHIVED = "ARCHIVED"
}
declare enum DomainTypeEnum {
    DOMAIN = "domain",
    SUBDOMAIN = "subdomain",
    HANDSHAKE_DOMAIN = "handshake-domain",
    HANDSHAKE_SUBDOMAIN = "handshake-subdomain",
    ENS_DOMAIN = "ens-domain"
}
declare enum DomainApplicationTypeEnum {
    WEB = 1,
    COMPUTE = 2
}
declare enum NodeVersionEnum {
    V_12 = "V_12",
    V_14 = "V_14",
    V_16 = "V_16"
}
declare enum FrameworkEnum {
    SIMPLE_JAVASCRIPT_APP = "static",
    VUE = "vue",
    REACT = "react",
    NEXT = "next",
    ANGULAR = "angular",
    PREACT = "preact",
    NUXT = "nuxt2",
    SVELTE = "svelte",
    GATSBY = "gatsby",
    ELEVENTY = "eleventy",
    DOCUSAURUS = "docusaurus",
    SANITY = "sanity",
    HUGO = "hugo",
    IONIC_REACT = "ionicreact",
    VITE = "vite",
    SCULLY = "scully",
    STENCIL = "stencil",
    BRUNCH = "brunch",
    IONIC_ANGULAR = "ionicangular"
}
declare enum DeploymentStatusEnum {
    PRE_QUEUE = "PreQueue",
    QUEUED = "Queued",
    PENDING = "Pending",
    CANCELED = "Canceled",
    DEPLOYED = "Deployed",
    FAILED = "Failed",
    AUTHORIZATION_NEEDED = "AuthorizationNeeded",
    KILLING = "Killing",
    TIMED_OUT = "TimedOut"
}
declare enum ProtocolEnum {
    ARWEAVE = "arweave",
    FILECOIN = "ipfs-filecoin",
    IPFS = "ipfs"
}

interface TokenScope {
    user: {
        id: string;
        username: string;
        name: string;
        email: string;
    };
    organizations: {
        id: string;
        name: string;
        username: string;
    }[];
}
interface DeploymentEnvironment {
    name: string;
    branches: string[];
    status: DeploymentEnvironmentStatusEnum;
    protocol: ProtocolEnum;
    isFree: boolean;
}
interface EnvironmentVariable {
    name: string;
    value: string;
    deploymentEnvironments: DeploymentEnvironment[];
}
interface Configuration {
    _id: string;
    buildCommand: string;
    installCommand: string;
    workspace: string;
    publishDir: string;
    framework: FrameworkEnum;
    nodeVersion: NodeVersionEnum;
}
interface PasswordProtection {
    enabled: boolean;
    credentials: string[];
}
interface Credentials {
    username: string;
    password: string;
}
interface Domain {
    _id: string;
    name: string;
    link: string;
    type: DomainTypeEnum;
    verified: boolean;
    projectId: string;
    deploymentEnvironmentIds: DeploymentEnvironment[];
    version: string;
    credentials: Credentials[];
    appType: DomainApplicationTypeEnum;
    createdAt: Date;
    updatedAt: Date;
}
interface Project {
    _id: string;
    name: string;
    type: ProjectTypeEnum;
    url: string;
    environmentVariables: EnvironmentVariable[];
    deploymentEnvironments: DeploymentEnvironment[];
    organization: string;
    state: ProjectStateEnum;
    hookId: string;
    provider: string;
    prCommentIds: {
        prId: string;
        commentId: string;
    }[];
    configuration: Configuration[];
    passwordProtection: PasswordProtection;
    createdAt: Date;
    updatedAt: Date;
    domains: Domain[];
}
interface Deployment {
    _id: string;
    sitePreview: string;
    commitId: string;
    commitMessage: string;
    logs: {
        time: string;
        log: string;
    }[];
    buildDirectory: string[];
    contentHash: string;
    topic: string;
    status: DeploymentStatusEnum;
    paymentId: string;
    buildTime: number;
    memoryUsed: number;
    env: object;
    project: Project;
    branch: string;
    externalRepositoryName: string;
    protocol: string;
    deploymentEnvironmentName: string;
    failedMessage: string;
    isFromRequest: boolean;
    configuration: Configuration;
    pickedUpByDeployerAt: number;
    encrypted: boolean;
    createdAt: Date;
    updatedAt: Date;
}
interface UsageWithLimits {
    usedBandwidth?: number;
    usedBuildExecution?: number;
    usedConcurrentBuild?: number;
    usedStorageArweave?: number;
    usedStorageFileCoin?: number;
    usedStorageIPFS?: number;
    usedDeploymentsPerDay?: number;
    lastDeploymentDate?: Date;
    usedDomains?: number;
    usedHnsDomains?: number;
    usedEnsDomains?: number;
    usedEnvironments?: number;
    usedClusterAkt?: number;
    usedClusterBuildExecution?: number;
    usedNumberOfRequests?: number;
    usedPasswordProtections?: number;
    membersLimit?: number;
    bandwidthLimit?: number;
    buildExecutionLimit?: number;
    concurrentBuildLimit?: number;
    storageArweaveLimit?: number;
    storageFileCoinLimit?: number;
    storageIPFSLimit?: number;
    deploymentsPerDayLimit?: number;
    domainsLimit?: number;
    hnsDomainsLimit?: number;
    ensDomainsLimit?: number;
    environmentsLimit?: number;
    clusterAktLimit?: number;
    clusterBuildExecutionLimit?: number;
    passwordProtectionLimit?: number;
}
interface UsageWithLimitsWithSkynet extends UsageWithLimits {
    usedStorageSkynet?: number;
    storageSkynetLimit?: number;
}

declare class SpheronApi {
    private readonly token;
    constructor(token: string);
    getTokenScope(): Promise<TokenScope>;
    getProject(projectId: string): Promise<Project>;
    getProjectDeployments(projectId: string, options: {
        skip: number;
        limit: number;
        status?: DeploymentStatusEnum;
    }): Promise<{
        deployments: Deployment[];
    }>;
    getProjectDomains(projectId: string): Promise<{
        domains: Domain[];
    }>;
    getProjectDomain(projectId: string, domainIdentifier: string): Promise<{
        domain: Domain;
    }>;
    addProjectDomain(projectId: string, options: {
        link: string;
        type: DomainTypeEnum | string;
        deploymentEnvironments: string[];
        name: string;
    }): Promise<{
        domain: Domain;
    }>;
    patchProjectDomain(projectId: string, domainIdentifier: string, options: {
        link: string;
        deploymentEnvironments: string[];
        name: string;
    }): Promise<{
        domain: Domain;
    }>;
    verifyProjectDomain(projectId: string, domainIdentifier: string): Promise<{
        success: boolean;
        domain: Domain;
    }>;
    deleteProjectDomain(projectId: string, domainIdentifier: string): Promise<void>;
    getProjectDeploymentCount(projectId: string): Promise<{
        total: number;
        successful: number;
        failed: number;
        pending: number;
    }>;
    updateProjectState(projectId: string, state: ProjectStateEnum | string): Promise<{
        message: string;
    }>;
    updateProjectConfiguration(projectId: string, options: {
        buildCommand: string;
        installCommand: string;
        workspace: string;
        publishDir: string;
        framework: FrameworkEnum | string;
        nodeVersion: NodeVersionEnum | string;
    }): Promise<{
        configuration: Configuration;
    }>;
    getDeployment(deploymentId: string): Promise<Deployment>;
    getOrganizationUsage(organizationId: string, specialization: "wa-global" | "c-akash"): Promise<UsageWithLimitsWithSkynet>;
    private sendApiRequest;
}

interface UploadMangerConfiguration {
    token: string;
}
interface UploadConfiguration {
    protocol: ProtocolEnum;
    name: string;
    organizationId?: string;
    onUploadInitiated?: (uploadId: string) => void;
    onChunkUploaded?: (uploadedSize: number) => void;
}
interface UploadResult {
    uploadId: string;
    bucketId: string;
    protocolLink: string;
    dynamicLinks: string[];
}
declare class UploadManager {
    initiateDeployment(configuration: {
        protocol: ProtocolEnum;
        name: string;
        organizationId?: string;
        token: string;
        createSingleDeploymentToken?: boolean;
    }): Promise<{
        deploymentId: string;
        parallelUploadCount: number;
        payloadSize: number;
        singleDeploymentToken?: string;
    }>;
    uploadPayloads(payloads: FormData[], configuration: {
        deploymentId: string;
        token: string;
        parallelUploadCount: number;
        onChunkUploaded?: (uploadedSize: number) => void;
    }): Promise<{
        success: boolean;
    }>;
    finalizeUploadDeployment(deploymentId: string, upload: boolean, token: string): Promise<{
        success: boolean;
        message: string;
        deploymentId: string;
        projectId: string;
        sitePreview: string;
        affectedDomains: string[];
    }>;
    private validateUploadConfiguration;
    private getAxiosRequestConfig;
}

export { Configuration, Deployment, DeploymentEnvironmentStatusEnum, DeploymentStatusEnum, Domain, DomainApplicationTypeEnum, DomainTypeEnum, FrameworkEnum, NodeVersionEnum, Project, ProjectStateEnum, ProjectTypeEnum, ProtocolEnum, SpheronApi, TokenScope, UploadConfiguration, UploadManager, UploadMangerConfiguration, UploadResult, UsageWithLimits, UsageWithLimitsWithSkynet };
