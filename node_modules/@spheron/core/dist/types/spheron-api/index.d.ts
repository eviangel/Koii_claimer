import { AppTypeEnum, DeploymentStatusEnum, DomainTypeEnum, FrameworkEnum, InstanceLogType, NodeVersionEnum, ProjectStateEnum, ProtocolEnum, ProviderEnum } from "./enums";
import { Configuration, Deployment, Domain, Organization, Project, TokenScope, User, DeploymentEnvironment, VerifiedTokenResponse, UsageWithLimitsWithSkynet, IPNSName, StartDeploymentConfiguration, EnvironmentVariable, Cluster, InstancesInfo, ClusterFundsUsage, ExtendedInstance, Instance, InstanceOrder, MarketplaceApp, ComputeMachine, InstanceOrderLogs, Bucket, BucketStateEnum, Upload, BucketDomain, BucketIpnsRecord } from "./interfaces";
import { CreateInstanceFromMarketplaceRequest, CreateInstanceRequest, UpdateInstaceRequest } from "./request-interfaces";
import { InstanceResponse, MarketplaceInstanceResponse } from "./response-interfaces";
declare class SpheronApi {
    private readonly spheronApiUrl;
    private readonly token;
    constructor(token: string, url?: string);
    getTokenScope(): Promise<TokenScope>;
    getProject(projectId: string): Promise<Project>;
    getProjectDeployments(projectId: string, options: {
        skip: number;
        limit: number;
        status?: DeploymentStatusEnum;
    }): Promise<{
        deployments: Deployment[];
    }>;
    getProjectDomains(projectId: string): Promise<{
        domains: Domain[];
    }>;
    getProjectDomain(projectId: string, domainIdentifier: string): Promise<{
        domain: Domain;
    }>;
    addProjectDomain(projectId: string, options: {
        link?: string;
        type: DomainTypeEnum | string;
        deploymentEnvironments?: string[];
        name: string;
    }): Promise<{
        domain: Domain;
    }>;
    patchProjectDomain(projectId: string, domainIdentifier: string, options: {
        link?: string;
        deploymentEnvironments?: string[];
        name: string;
    }): Promise<{
        domain: Domain;
    }>;
    verifyProjectDomain(projectId: string, domainIdentifier: string): Promise<{
        success: boolean;
        domain: Domain;
    }>;
    deleteProjectDomain(projectId: string, domainIdentifier: string): Promise<void>;
    getCdnRecords(): Promise<{
        recordIpv4V2: string;
        recordCnameV2: string;
    }>;
    getProjectDeploymentCount(projectId: string): Promise<{
        total: number;
        successful: number;
        failed: number;
        pending: number;
    }>;
    updateProjectState(projectId: string, state: ProjectStateEnum | string): Promise<{
        message: string;
    }>;
    updateProjectConfiguration(projectId: string, options: {
        buildCommand: string;
        installCommand: string;
        workspace: string;
        publishDir: string;
        framework: FrameworkEnum | string;
        nodeVersion: NodeVersionEnum | string;
    }): Promise<{
        configuration: Configuration;
    }>;
    createOrganization(username: string, name: string, appType: AppTypeEnum): Promise<Organization>;
    getOrganization(id: string): Promise<Organization>;
    updateOrganization(organizationId: string, options: {
        name: string;
        username: string;
        image: string;
    }): Promise<Organization>;
    getOrganizationProjects(id: string, options: {
        skip: number;
        limit: number;
        state?: ProjectStateEnum;
    }): Promise<Project[]>;
    getOrganizationProjectCount(id: string, options: {
        state?: ProjectStateEnum;
    }): Promise<number>;
    getProfile(): Promise<User>;
    verfiyGitToken(provider: string, code: string, port: number): Promise<VerifiedTokenResponse>;
    getOrganizationUsage(organizationId: string, specialization: "wa-global" | "c-akash" | "storage"): Promise<UsageWithLimitsWithSkynet>;
    publishIPNS(deploymentId: string): Promise<IPNSName>;
    updateIPNSName(ipnsNameId: string, deploymentId: string): Promise<IPNSName>;
    getIPNSName(ipnsNameId: string): Promise<IPNSName>;
    getIPNSNamesForUpload(uploadId: string): Promise<IPNSName[]>;
    getIPNSNamesForOrganization(organizationId: string): Promise<IPNSName[]>;
    startDeployment(configuration: StartDeploymentConfiguration): Promise<{
        success: boolean;
        message: string;
        topic: string;
        deploymentId: string;
        projectId: string;
        deployment: Deployment;
    }>;
    authorizeDeployment(deploymentId: string): Promise<{
        success: boolean;
        message: string;
        topic: string;
        deploymentId: string;
        projectId: string;
        deployment: Deployment;
    }>;
    cancelDeployment(deploymentId: string): Promise<{
        message: string;
        canceled: true;
        killing: true;
    }>;
    redeployDeployment(deploymentId: string): Promise<{
        success: boolean;
        message: string;
        topic: string;
        deploymentId: string;
        projectId: string;
        deployment: Deployment;
    }>;
    getDeployment(deploymentId: string): Promise<Deployment>;
    suggestFramework(options: {
        owner: string;
        branch: string;
        provider: ProviderEnum;
        repositoryName: string;
        root?: string;
    }): Promise<{
        suggestedFramework: FrameworkEnum;
    }>;
    addProjectEnvironmentVariables(projectId: string, environmentVariables: {
        name: string;
        value: string;
        environments: string[];
    }[]): Promise<{
        environmentVariables: EnvironmentVariable[];
    }>;
    updateProjectEnvironmentVariable(projectId: string, environmentVariableId: string, payload: {
        name: string;
        value: string;
        environments: string[];
    }): Promise<EnvironmentVariable>;
    deleteProjectEnvironmentVariable(projectId: string, environmentVariableId: string): Promise<void>;
    getDeploymentEnvironments(projectId: string): Promise<DeploymentEnvironment[]>;
    createDeploymentEnvironment(projectId: string, payload: {
        name: string;
        branches: string[];
        protocol: ProtocolEnum;
    }): Promise<DeploymentEnvironment>;
    updateDeploymentEnvironment(projectId: string, deploymentEnvironmentId: string, payload: {
        name: string;
        branches: string[];
        protocol: ProtocolEnum;
    }): Promise<DeploymentEnvironment>;
    deleteDeploymentEnvironment(projectId: string, deploymentEnvironmentId: string): Promise<{
        message: string;
    }>;
    activateDeploymentEnvironment(projectId: string, deploymentEnvironmentId: string): Promise<DeploymentEnvironment>;
    deactivateDeploymentEnvironment(projectId: string, deploymentEnvironmentId: string): Promise<DeploymentEnvironment>;
    getOrganizationClusters(id: string, options: {
        skip: number;
        limit: number;
    }): Promise<Cluster[]>;
    getCluster(id: string): Promise<Cluster>;
    deleteCluster(id: string): Promise<void>;
    getClusterInstancesDetails(id: string): Promise<InstancesInfo>;
    getClusterFundsUsage(id: string): Promise<ClusterFundsUsage>;
    getClusterInstances(id: string, options: {
        skip: number;
        limit: number;
        includeReport?: boolean;
    }): Promise<ExtendedInstance[]>;
    getClusterTemplates(): Promise<MarketplaceApp[]>;
    getClusterTemplate(id: string): Promise<MarketplaceApp>;
    getClusterCategories(): Promise<string[]>;
    getClusterInstance(id: string, options?: {
        includeReport?: boolean;
    }): Promise<Instance>;
    deleteClusterInstance(id: string): Promise<void>;
    updateClusterInstance(id: string, organizationId: string, clusterInstance: UpdateInstaceRequest): Promise<InstanceResponse>;
    updateClusterInstanceHealthCheckInfo(id: string, healthCheck: {
        path: string;
        cointainerPort: number;
    }): Promise<{
        message: string;
        updated: boolean;
    }>;
    closeClusterInstance(id: string): Promise<{
        message: string;
        success: boolean;
    }>;
    getClusterInstanceOrder(id: string): Promise<{
        order: InstanceOrder;
        liveLogs: string[];
    }>;
    getClusterInstanceOrderLogs(id: string, logsOptions: {
        from: number;
        to: number;
        logType: InstanceLogType;
        search?: string;
    }): Promise<InstanceOrderLogs>;
    createClusterInstance(clusterInstance: CreateInstanceRequest): Promise<InstanceResponse>;
    createClusterInstanceFromTemplate(clusterInstance: CreateInstanceFromMarketplaceRequest): Promise<MarketplaceInstanceResponse>;
    getClusterInstanceDomains(id: string): Promise<Domain[]>;
    addClusterInstanceDomain(instanceId: string, doamin: {
        link: string;
        type: DomainTypeEnum | string;
        name: string;
    }): Promise<Domain>;
    updateClusterInstanceDomain(instanceId: string, domainId: string, doamin: {
        link: string;
        type: DomainTypeEnum | string;
        name: string;
    }): Promise<Domain>;
    deleteClusterInstanceDomain(instanceId: string, domainId: string): Promise<void>;
    verifyClusterInstanceDomain(instanceId: string, domainId: string): Promise<void>;
    getComputeMachines(options: {
        skip: number;
        limit: number;
        searchString?: string;
    }): Promise<ComputeMachine[]>;
    getComputeMachineRegions(): Promise<string[]>;
    triggerClusterInstanceHealthCheck(instanceId: string, topicId: string): Promise<{
        topicId: string;
        message: string;
    }>;
    triggerClusterInstanceStatusCheck(instanceId: string, topicId: string): Promise<{
        topicId: string;
        message: string;
    }>;
    triggerClusterInstanceLogFetch(instanceId: string, topicId: string): Promise<{
        topicId: string;
        message: string;
    }>;
    getPriceForToken(tokenId: number): Promise<number>;
    getGPTResponse(body: {
        query: string;
    }): Promise<{
        response: string;
    }>;
    isWhitelisted(): Promise<any>;
    getOrganizationBuckets({ organizationId, name, state, skip, limit, }: {
        organizationId: string;
        name?: string;
        state?: BucketStateEnum;
        skip: number;
        limit: number;
    }): Promise<{
        buckets: Bucket[];
    }>;
    getOrganizationBucketCount({ organizationId, name, state, }: {
        organizationId: string;
        name?: string;
        state?: BucketStateEnum;
    }): Promise<{
        count: number;
    }>;
    getBucket(bucketId: string): Promise<Bucket>;
    updateBucketState(bucketId: string, state: BucketStateEnum): Promise<Bucket>;
    getBucketDomains(bucketId: string): Promise<{
        domains: BucketDomain[];
    }>;
    getBucketDomain(bucketId: string, domainIdentifier: string): Promise<{
        domain: BucketDomain;
    }>;
    addBucketDomain(bucketId: string, options: {
        link?: string;
        type: DomainTypeEnum | string;
        name: string;
    }): Promise<{
        domain: BucketDomain;
    }>;
    patchBucketDomain(bucketId: string, domainIdentifier: string, options: {
        link?: string;
        name: string;
    }): Promise<{
        domain: BucketDomain;
    }>;
    verifyBucketDomain(bucketId: string, domainIdentifier: string): Promise<{
        success: boolean;
        domain: BucketDomain;
    }>;
    deleteBucketDomain(bucketId: string, domainIdentifier: string): Promise<void>;
    getBucketIpnsRecords(bucketId: string): Promise<{
        ipnsRecords: BucketIpnsRecord[];
    }>;
    getBucketIpnsRecord(bucketId: string, ipnsRecordId: string): Promise<{
        ipnsRecord: BucketIpnsRecord;
    }>;
    addBucketIpnsRecord(bucketId: string, uploadId: string): Promise<{
        ipnsRecord: BucketIpnsRecord;
    }>;
    patchBucketIpnsRecord(bucketId: string, ipnsRecordId: string, uploadId: string): Promise<{
        ipnsRecord: BucketIpnsRecord;
    }>;
    deleteBucketIpnsRecord(bucketId: string, ipnsRecordId: string): Promise<void>;
    getBucketUploads(bucketId: string, options: {
        skip: number;
        limit: number;
    }): Promise<{
        uploads: Upload[];
    }>;
    getBucketUploadCount(bucketId: string): Promise<{
        count: number;
    }>;
    migrateStaticSiteOrgToStorage(webappOrganizationId: string, storageOrganizationId: string): Promise<{
        numberOfBuckets: number;
        numberOfUploads: number;
    }>;
    getUpload(uploadId: string): Promise<Upload>;
    pinUpload(uploadId: string): Promise<Upload>;
    unpinUpload(uploadId: string): Promise<Upload>;
    private sendApiRequest;
    private mapIPNSResponseToIPNSName;
}
export default SpheronApi;
