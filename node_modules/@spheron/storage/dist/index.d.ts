import { DomainTypeEnum, BucketStateEnum, UploadedFile, UploadStatusEnum, ScopeExtractor, ProtocolEnum, UploadResult, PinStatus, TokenScope } from '@spheron/core';
export { BucketStateEnum, DomainTypeEnum, ProtocolEnum, TokenScope, UploadStatusEnum } from '@spheron/core';
import { AuthSig, AccessControlConditions, EvmContractConditions, SolRpcConditions, UnifiedAccessControlConditions, Chain } from '@spheron/encryption';
export { uint8arrayToString } from '@spheron/encryption';

interface Domain {
    id: string;
    name: string;
    link: string;
    verified: boolean;
    bucketId: string;
    type: DomainTypeEnum;
}
interface IpnsRecord {
    id: string;
    ipnsHash: string;
    ipnsLink: string;
    bucketId: string;
    createdAt: Date;
    updatedAt: Date;
    memoryUsed: number;
}
interface Bucket {
    id: string;
    name: string;
    organizationId: string;
    state: BucketStateEnum;
}
interface Upload {
    id: string;
    protocolLink: string;
    uploadDirectory: UploadedFile[];
    status: UploadStatusEnum;
    memoryUsed: number;
    bucketId: string;
    protocol: string;
}
interface UsageWithLimits {
    used: {
        bandwidth: number;
        storageArweave: number;
        storageIPFS: number;
        storageFilecoin: number;
        domains: number;
        hnsDomains: number;
        ensDomains: number;
        numberOfRequests: number;
        parallelUploads: number;
        imageOptimization: number;
        ipfsBandwidth: number;
        ipfsNumberOfRequests: number;
    };
    limit: {
        bandwidth: number;
        storageArweave: number;
        storageIPFS: number;
        domains: number;
        hnsDomains: number;
        ensDomains: number;
        parallelUploads: number;
        imageOptimization: number;
        ipfsBandwidth: number;
    };
}

declare const ipfs: {
    utils: {
        toV0: (v1: string) => string;
        toV1: (v0: string) => string;
    };
};

interface EncryptToIpfsProps {
    authSig?: AuthSig;
    sessionSigs?: any;
    accessControlConditions?: AccessControlConditions;
    evmContractConditions?: EvmContractConditions;
    solRpcConditions?: SolRpcConditions;
    unifiedAccessControlConditions?: UnifiedAccessControlConditions;
    chain: Chain;
    string?: string;
    filePath?: string;
    litNodeClient: any;
    configuration: {
        name: string;
        onUploadInitiated?: (uploadId: string) => void;
        onChunkUploaded?: (uploadedSize: number, totalSize: number) => void;
    };
}
interface DecryptFromIpfsProps {
    authSig?: AuthSig;
    sessionSigs?: any;
    ipfsCid: string;
    litNodeClient: any;
}

interface SpheronClientConfiguration {
    token: string;
    apiUrl?: string;
}
declare class SpheronClient extends ScopeExtractor {
    private readonly configuration;
    private readonly spheronApi;
    private readonly bucketManager;
    private readonly uploadManager;
    constructor(configuration: SpheronClientConfiguration);
    upload(path: string, configuration: {
        name: string;
        protocol: ProtocolEnum;
        organizationId?: string;
        onUploadInitiated?: (uploadId: string) => void;
        onChunkUploaded?: (uploadedSize: number, totalSize: number) => void;
    }): Promise<UploadResult>;
    encryptUpload({ authSig, sessionSigs, accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions, chain, string, filePath, litNodeClient, configuration, }: EncryptToIpfsProps): Promise<UploadResult>;
    decryptUpload({ authSig, sessionSigs, ipfsCid, litNodeClient, }: DecryptFromIpfsProps): Promise<Uint8Array>;
    createSingleUploadToken(configuration: {
        name: string;
        protocol: ProtocolEnum;
        maxSize?: number;
    }): Promise<{
        uploadToken: string;
    }>;
    pinCID(configuration: {
        name: string;
        cid: string;
        inBackground?: boolean;
    }): Promise<{
        uploadId: string;
        bucketId: string;
        protocolLink: string;
        dynamicLinks: string[];
    }>;
    pinCIDs(configuration: {
        name: string;
        cids: string[];
    }): Promise<{
        uploadId: string;
        cid: string;
    }[]>;
    getOrganizationBuckets(organizationId: string, options: {
        name?: string;
        state?: BucketStateEnum;
        skip: number;
        limit: number;
    }): Promise<Bucket[]>;
    getOrganizationBucketCount(organizationId: string, options?: {
        name?: string;
        state?: BucketStateEnum;
    }): Promise<number>;
    getBucket(bucketId: string): Promise<Bucket>;
    getCIDStatus(CID: string): Promise<{
        pinStatus: PinStatus;
    }>;
    getBucketDomains(bucketId: string): Promise<Domain[]>;
    getBucketDomain(bucketId: string, domainIdentifier: string): Promise<Domain>;
    addBucketDomain(bucketId: string, options: {
        link: string;
        type: DomainTypeEnum | "domain" | "subdomain" | "handshake-domain" | "handshake-subdomain" | "ens-domain";
        name: string;
    }): Promise<Domain>;
    updateBucketDomain(bucketId: string, domainIdentifier: string, options: {
        link: string;
        name: string;
    }): Promise<Domain>;
    verifyBucketDomain(bucketId: string, domainIdentifier: string): Promise<Domain>;
    getCdnDnsRecords(): Promise<{
        cdnARecords: string;
        cdnCnameRecords: string;
    }>;
    deleteBucketDomain(bucketId: string, domainIdentifier: string): Promise<void>;
    archiveBucket(bucketId: string): Promise<void>;
    unarchiveBucket(bucketId: string): Promise<void>;
    getBucketUploadCount(bucketId: string): Promise<number>;
    getBucketUploads(bucketId: string, options: {
        skip: number;
        limit: number;
    }): Promise<Upload[]>;
    getUpload(uploadId: string): Promise<Upload>;
    pinUpload(uploadId: string): Promise<Upload>;
    unpinUpload(uploadId: string): Promise<Upload>;
    getOrganizationUsage(organizationId: string): Promise<UsageWithLimits>;
    getTokenScope(): Promise<TokenScope>;
    getBucketIpnsRecords(bucketId: string): Promise<IpnsRecord[]>;
    getBucketIpnsRecord(bucketId: string, ipnsRecordId: string): Promise<IpnsRecord>;
    addBucketIpnsRecord(bucketId: string, uploadId: string): Promise<IpnsRecord>;
    updateBucketIpnsRecord(bucketId: string, ipnsRecordId: string, uploadId: string): Promise<IpnsRecord>;
    deleteBucketIpnsRecord(bucketId: string, ipnsRecordId: string): Promise<void>;
    migrateStaticSiteOrgToStorage(staticSiteOrganizationId: string, storageOrganizationId: string): Promise<{
        numberOfBuckets: number;
        numberOfUploads: number;
    }>;
    private validateStorageOrganizationType;
}

export { Bucket, Domain, IpnsRecord, SpheronClient, SpheronClientConfiguration, Upload, UsageWithLimits, SpheronClient as default, ipfs };
