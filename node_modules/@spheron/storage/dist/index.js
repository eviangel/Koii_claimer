"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BucketStateEnum: () => import_core.BucketStateEnum,
  DomainTypeEnum: () => import_core2.DomainTypeEnum,
  ProtocolEnum: () => import_core3.ProtocolEnum,
  SpheronClient: () => SpheronClient,
  TokenScope: () => import_core3.TokenScope,
  UploadStatusEnum: () => import_core.UploadStatusEnum,
  default: () => src_default,
  ipfs: () => ipfs,
  uint8arrayToString: () => import_encryption.uint8arrayToString
});
module.exports = __toCommonJS(src_exports);

// src/bucket-manager/index.ts
var import_core2 = require("@spheron/core");

// src/bucket-manager/interfaces.ts
var import_core = require("@spheron/core");

// src/bucket-manager/index.ts
var BucketManager = class {
  constructor(spheronApi) {
    this.spheronApi = spheronApi;
  }
  getOrganizationBuckets(organizationId, options) {
    return __async(this, null, function* () {
      const { buckets } = yield this.spheronApi.getOrganizationBuckets(__spreadValues({
        organizationId
      }, options));
      return buckets.map((x) => this.mapCoreBucket(x));
    });
  }
  getOrganizationBucketCount(organizationId, options) {
    return __async(this, null, function* () {
      const { count } = yield this.spheronApi.getOrganizationBucketCount(__spreadValues({
        organizationId
      }, options));
      return count;
    });
  }
  getBucket(bucketId) {
    return __async(this, null, function* () {
      const bucket = yield this.spheronApi.getBucket(bucketId);
      return this.mapCoreBucket(bucket);
    });
  }
  getBucketDomains(bucketId) {
    return __async(this, null, function* () {
      const { domains } = yield this.spheronApi.getBucketDomains(bucketId);
      return domains.map((x) => this.mapCoreBucketDomains(x));
    });
  }
  getBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      const { domain } = yield this.spheronApi.getBucketDomain(
        bucketId,
        domainIdentifier
      );
      return this.mapCoreBucketDomains(domain);
    });
  }
  updateBucketDomain(bucketId, domainIdentifier, options) {
    return __async(this, null, function* () {
      const { domain } = yield this.spheronApi.patchBucketDomain(
        bucketId,
        domainIdentifier,
        __spreadValues({}, options)
      );
      return this.mapCoreBucketDomains(domain);
    });
  }
  verifyBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      const { domain } = yield this.spheronApi.verifyBucketDomain(
        bucketId,
        domainIdentifier
      );
      return this.mapCoreBucketDomains(domain);
    });
  }
  deleteBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      yield this.spheronApi.deleteBucketDomain(bucketId, domainIdentifier);
    });
  }
  addBucketDomain(bucketId, options) {
    return __async(this, null, function* () {
      const { domain } = yield this.spheronApi.addBucketDomain(bucketId, __spreadValues({}, options));
      return this.mapCoreBucketDomains(domain);
    });
  }
  getBucketUploads(bucketId, options) {
    return __async(this, null, function* () {
      if (options.skip < 0 || options.limit < 0) {
        throw new Error(`Skip and Limit cannot be negative numbers.`);
      }
      const { uploads } = yield this.spheronApi.getBucketUploads(bucketId, {
        skip: options.skip && options.skip >= 0 ? options.skip : 0,
        limit: options.limit && options.limit >= 0 ? options.limit : 6
      });
      return uploads.map((x) => this.mapCoreUpload(x));
    });
  }
  getBucketUploadCount(bucketId) {
    return __async(this, null, function* () {
      const { count } = yield this.spheronApi.getBucketUploadCount(bucketId);
      return count;
    });
  }
  archiveBucket(bucketId) {
    return __async(this, null, function* () {
      yield this.spheronApi.updateBucketState(bucketId, import_core.BucketStateEnum.ARCHIVED);
    });
  }
  unarchiveBucket(bucketId) {
    return __async(this, null, function* () {
      yield this.spheronApi.updateBucketState(
        bucketId,
        import_core.BucketStateEnum.MAINTAINED
      );
    });
  }
  getUpload(uploadId) {
    return __async(this, null, function* () {
      const upload = yield this.spheronApi.getUpload(uploadId);
      return this.mapCoreUpload(upload);
    });
  }
  pinUpload(uploadId) {
    return __async(this, null, function* () {
      const upload = yield this.spheronApi.pinUpload(uploadId);
      return this.mapCoreUpload(upload);
    });
  }
  unpinUpload(uploadId) {
    return __async(this, null, function* () {
      const upload = yield this.spheronApi.unpinUpload(uploadId);
      return this.mapCoreUpload(upload);
    });
  }
  getBucketIpnsRecords(bucketId) {
    return __async(this, null, function* () {
      const { ipnsRecords } = yield this.spheronApi.getBucketIpnsRecords(
        bucketId
      );
      return ipnsRecords.map((x) => this.mapCoreIpnsRecord(x));
    });
  }
  getBucketIpnsRecord(bucketId, ipnsRecordId) {
    return __async(this, null, function* () {
      const { ipnsRecord } = yield this.spheronApi.getBucketIpnsRecord(
        bucketId,
        ipnsRecordId
      );
      return this.mapCoreIpnsRecord(ipnsRecord);
    });
  }
  addBucketIpnsRecord(bucketId, uploadId) {
    return __async(this, null, function* () {
      const { ipnsRecord } = yield this.spheronApi.addBucketIpnsRecord(
        bucketId,
        uploadId
      );
      return this.mapCoreIpnsRecord(ipnsRecord);
    });
  }
  updateBucketIpnsRecord(bucketId, ipnsRecordId, uploadId) {
    return __async(this, null, function* () {
      const { ipnsRecord } = yield this.spheronApi.patchBucketIpnsRecord(
        bucketId,
        ipnsRecordId,
        uploadId
      );
      return this.mapCoreIpnsRecord(ipnsRecord);
    });
  }
  deleteBucketIpnsRecord(bucketId, ipnsRecordId) {
    return __async(this, null, function* () {
      yield this.spheronApi.deleteBucketIpnsRecord(bucketId, ipnsRecordId);
    });
  }
  mapCoreBucket(bucket) {
    return {
      id: bucket._id,
      name: bucket.name,
      organizationId: bucket.organization,
      state: bucket.state
    };
  }
  mapCoreBucketDomains(domain) {
    return {
      id: domain._id,
      name: domain.name,
      link: domain.link,
      verified: domain.verified,
      bucketId: domain.bucketId,
      type: domain.type
    };
  }
  mapCoreUpload(upload) {
    return {
      id: upload._id,
      protocolLink: upload.protocolLink,
      uploadDirectory: upload.uploadDirectory,
      status: upload.status,
      memoryUsed: upload.memoryUsed,
      bucketId: upload.bucket,
      protocol: upload.protocol
    };
  }
  mapCoreIpnsRecord(ipnsRecord) {
    return {
      id: ipnsRecord._id,
      ipnsHash: ipnsRecord.keyId,
      ipnsLink: ipnsRecord.ipnsLink,
      bucketId: ipnsRecord.bucket,
      createdAt: ipnsRecord.createdAt,
      updatedAt: ipnsRecord.updatedAt,
      memoryUsed: ipnsRecord.memoryUsed
    };
  }
};
var bucket_manager_default = BucketManager;

// src/index.ts
var import_core3 = require("@spheron/core");

// src/fs-payload-creator.ts
var import_fs = __toESM(require("fs"));
var import_form_data = __toESM(require("form-data"));
var import_path = __toESM(require("path"));
var createPayloads = (path2, payloadSize) => __async(void 0, null, function* () {
  const uploadContext = {
    payloads: new Array(),
    currentPayload: null,
    currentPayloadSize: 0,
    totalSize: 0
  };
  yield fillUploadContext(path2, "./", uploadContext, true, payloadSize);
  if (uploadContext.currentPayload) {
    uploadContext.payloads.push(uploadContext.currentPayload);
  }
  return {
    payloads: uploadContext.payloads,
    totalSize: uploadContext.totalSize
  };
});
var fillUploadContext = (pathToFile, rootPath, uploadContext, isRoot, payloadSize) => __async(void 0, null, function* () {
  const stat = yield import_fs.default.promises.stat(pathToFile);
  if (stat.isFile()) {
    const fileName = import_path.default.basename(pathToFile);
    processFile(
      pathToFile,
      rootPath + fileName,
      stat,
      uploadContext,
      payloadSize
    );
    return;
  }
  const files = yield import_fs.default.promises.readdir(pathToFile);
  for (const file of files) {
    yield fillUploadContext(
      `${pathToFile}/${file}`,
      isRoot ? "./" : `${rootPath}${import_path.default.basename(pathToFile)}/`,
      uploadContext,
      false,
      payloadSize
    );
  }
});
var processFile = (fullPath, uploadPath, stat, uploadContext, payloadSize) => __async(void 0, null, function* () {
  uploadContext.totalSize += stat.size;
  if (stat.size > payloadSize) {
    const numOfChunks = Math.ceil(stat.size / payloadSize);
    for (let i = 0; i < numOfChunks; i++) {
      const start = i * payloadSize;
      const end = start + payloadSize - 1;
      const form = new import_form_data.default();
      form.append(
        `chunk-${i}-${numOfChunks}`,
        import_fs.default.createReadStream(fullPath, { start, end }),
        {
          filepath: uploadPath
        }
      );
      uploadContext.payloads.push(form);
    }
  } else {
    if (!uploadContext.currentPayload) {
      uploadContext.currentPayload = new import_form_data.default();
    }
    uploadContext.currentPayload.append(
      "files",
      import_fs.default.createReadStream(fullPath),
      {
        filepath: uploadPath
      }
    );
    uploadContext.currentPayloadSize += stat.size;
    if (uploadContext.currentPayloadSize > payloadSize) {
      uploadContext.payloads.push(uploadContext.currentPayload);
      uploadContext.currentPayload = null;
      uploadContext.currentPayloadSize = 0;
    }
  }
});

// src/ipfs.utils.ts
var import_cid = require("multiformats/cid");
var ipfs = {
  utils: {
    toV0: (v1) => {
      const cid = import_cid.CID.parse(v1);
      if (cid.version === 0)
        return v1;
      return cid.toV0().toString();
    },
    toV1: (v0) => {
      const cid = import_cid.CID.parse(v0);
      if (cid.version === 1)
        return v0;
      return cid.toV1().toString();
    }
  }
};

// src/index.ts
var import_encryption = require("@spheron/encryption");

// src/utils.ts
var import_fs2 = __toESM(require("fs"));
function readFileContent(filePath) {
  return __async(this, null, function* () {
    const exists = import_fs2.default.promises.access(filePath, import_fs2.default.constants.F_OK);
    if (!exists) {
      throw new Error("File does not exist.");
    }
    const fileBuffer = yield import_fs2.default.promises.readFile(filePath);
    const fileContent = new Uint8Array(fileBuffer);
    return {
      content: fileContent
    };
  });
}

// src/index.ts
var import_form_data2 = __toESM(require("form-data"));
var SpheronClient = class extends import_core3.ScopeExtractor {
  constructor(configuration) {
    const spheronApi = new import_core3.SpheronApi(
      configuration.token,
      configuration == null ? void 0 : configuration.apiUrl
    );
    super(spheronApi);
    this.spheronApi = spheronApi;
    this.configuration = configuration;
    this.bucketManager = new bucket_manager_default(this.spheronApi);
    this.uploadManager = new import_core3.UploadManager(configuration == null ? void 0 : configuration.apiUrl);
  }
  upload(path2, configuration) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      const { uploadId, payloadSize, parallelUploadCount } = yield this.uploadManager.initiateUpload({
        protocol: configuration.protocol,
        name: configuration.name,
        organizationId: configuration.organizationId,
        token: this.configuration.token
      });
      let success = true;
      let caughtError = void 0;
      try {
        const { payloads, totalSize } = yield createPayloads(path2, payloadSize);
        configuration.onUploadInitiated && configuration.onUploadInitiated(uploadId);
        const uploadPayloadsResult = yield this.uploadManager.uploadPayloads(
          payloads,
          {
            uploadId,
            token: this.configuration.token,
            parallelUploadCount,
            onChunkUploaded: (uploadedSize) => configuration.onChunkUploaded && configuration.onChunkUploaded(uploadedSize, totalSize)
          }
        );
        if (!uploadPayloadsResult.success) {
          throw new Error(uploadPayloadsResult.errorMessage);
        }
      } catch (error) {
        success = false;
        caughtError = error;
      }
      const result = yield this.uploadManager.finalizeUpload(
        uploadId,
        success,
        this.configuration.token
      );
      if (caughtError) {
        throw caughtError;
      }
      if (!result.success) {
        throw new Error(`Upload failed. ${result.message}`);
      }
      return {
        uploadId: result.uploadId,
        bucketId: result.bucketId,
        protocolLink: result.protocolLink,
        dynamicLinks: result.dynamicLinks,
        cid: result.cid
      };
    });
  }
  encryptUpload(_0) {
    return __async(this, arguments, function* ({
      authSig,
      sessionSigs,
      accessControlConditions,
      evmContractConditions,
      solRpcConditions,
      unifiedAccessControlConditions,
      chain,
      string,
      filePath,
      litNodeClient,
      configuration
    }) {
      yield this.validateStorageOrganizationType();
      if (!string && !filePath) {
        throw new Error(`Either string or filePath must be provided`);
      }
      if (!configuration.name) {
        throw new Error(`Name must be provided`);
      }
      let dataToEncrypt = null;
      if (string && filePath) {
        throw new Error(`Provide only either a string or filePath to encrypt`);
      } else if (string !== void 0) {
        dataToEncrypt = (0, import_encryption.uint8arrayFromString)(string, "utf8");
      } else if (filePath !== void 0) {
        const { content } = yield readFileContent(filePath);
        dataToEncrypt = content;
      } else {
        throw new Error(`Either string or file must be provided`);
      }
      if (!dataToEncrypt) {
        throw new Error(`No data to encrypt`);
      }
      const { encryptedData, symmetricKey } = yield (0, import_encryption.encryptData)(dataToEncrypt);
      const encryptedSymmetricKey = yield litNodeClient.saveEncryptionKey({
        accessControlConditions,
        evmContractConditions,
        solRpcConditions,
        unifiedAccessControlConditions,
        symmetricKey,
        authSig,
        sessionSigs,
        chain
      });
      const encryptedSymmetricKeyString = (0, import_encryption.uint8arrayToString)(
        encryptedSymmetricKey,
        "base16"
      );
      const encryptedDataJson = Buffer.from(encryptedData.buffer).toJSON();
      try {
        const uploadJson = JSON.stringify({
          encryptedData: encryptedDataJson,
          encryptedSymmetricKeyString,
          accessControlConditions,
          evmContractConditions,
          solRpcConditions,
          unifiedAccessControlConditions,
          chain
        });
        const { uploadId, parallelUploadCount } = yield this.uploadManager.initiateUpload({
          protocol: import_core3.ProtocolEnum.IPFS,
          name: configuration.name,
          token: this.configuration.token
        });
        configuration.onUploadInitiated && configuration.onUploadInitiated(uploadId);
        let success = true;
        let caughtError = void 0;
        const totalSize = Buffer.byteLength(uploadJson, "utf8");
        try {
          const form = new import_form_data2.default();
          form.append("files", uploadJson, "data.json");
          const uploadPayloadsResult = yield this.uploadManager.uploadPayloads(
            [form],
            {
              uploadId,
              token: this.configuration.token,
              parallelUploadCount,
              onChunkUploaded: (uploadedSize) => configuration.onChunkUploaded && configuration.onChunkUploaded(uploadedSize, totalSize)
            }
          );
          if (!uploadPayloadsResult.success) {
            throw new Error(uploadPayloadsResult.errorMessage);
          }
        } catch (error) {
          success = false;
          caughtError = error;
        }
        const result = yield this.uploadManager.finalizeUpload(
          uploadId,
          success,
          this.configuration.token
        );
        if (caughtError) {
          throw caughtError;
        }
        if (!result.success) {
          throw new Error(`Upload failed. ${result.message}`);
        }
        return {
          uploadId: result.uploadId,
          bucketId: result.bucketId,
          protocolLink: result.protocolLink,
          dynamicLinks: result.dynamicLinks,
          cid: result.cid
        };
      } catch (e) {
        throw new Error(`Upload failed: ${e.message}`);
      }
    });
  }
  decryptUpload(_0) {
    return __async(this, arguments, function* ({
      authSig,
      sessionSigs,
      ipfsCid,
      litNodeClient
    }) {
      yield this.validateStorageOrganizationType();
      const metadata = yield (yield fetch(`https://${ipfsCid}.ipfs.sphn.link/data.json`).catch(() => {
        throw new Error("Error finding metadata from IPFS CID");
      })).json();
      const symmetricKey = yield litNodeClient.getEncryptionKey({
        accessControlConditions: metadata.accessControlConditions,
        evmContractConditions: metadata.evmContractConditions,
        solRpcConditions: metadata.solRpcConditions,
        unifiedAccessControlConditions: metadata.unifiedAccessControlConditions,
        toDecrypt: metadata.encryptedSymmetricKeyString,
        chain: metadata.chain,
        authSig,
        sessionSigs
      });
      const encrypted = new Uint8Array(Buffer.from(metadata.encryptedData));
      return (0, import_encryption.decryptData)(encrypted, symmetricKey);
    });
  }
  createSingleUploadToken(configuration) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      const { singleUseToken } = yield this.uploadManager.initiateUpload({
        protocol: configuration.protocol,
        name: configuration.name,
        token: this.configuration.token,
        createSingleUseToken: true,
        maxSize: configuration.maxSize
      });
      return { uploadToken: singleUseToken };
    });
  }
  pinCID(configuration) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.uploadManager.pinCID({
        name: configuration.name,
        token: this.configuration.token,
        cid: configuration.cid,
        inBackground: configuration.inBackground
      });
    });
  }
  pinCIDs(configuration) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.uploadManager.pinCIDs({
        name: configuration.name,
        cids: configuration.cids,
        token: this.configuration.token
      });
    });
  }
  getOrganizationBuckets(organizationId, options) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.getOrganizationBuckets(
        organizationId,
        options
      );
    });
  }
  getOrganizationBucketCount(organizationId, options) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.getOrganizationBucketCount(
        organizationId,
        options
      );
    });
  }
  getBucket(bucketId) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.getBucket(bucketId);
    });
  }
  getCIDStatus(CID2) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.uploadManager.getCIDStatus(CID2);
    });
  }
  getBucketDomains(bucketId) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.getBucketDomains(bucketId);
    });
  }
  getBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.getBucketDomain(bucketId, domainIdentifier);
    });
  }
  addBucketDomain(bucketId, options) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.addBucketDomain(bucketId, options);
    });
  }
  updateBucketDomain(bucketId, domainIdentifier, options) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.updateBucketDomain(
        bucketId,
        domainIdentifier,
        options
      );
    });
  }
  verifyBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.verifyBucketDomain(
        bucketId,
        domainIdentifier
      );
    });
  }
  getCdnDnsRecords() {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      const { recordIpv4V2, recordCnameV2 } = yield this.spheronApi.getCdnRecords();
      return {
        cdnARecords: recordIpv4V2,
        cdnCnameRecords: recordCnameV2
      };
    });
  }
  deleteBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.deleteBucketDomain(
        bucketId,
        domainIdentifier
      );
    });
  }
  archiveBucket(bucketId) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      yield this.bucketManager.archiveBucket(bucketId);
    });
  }
  unarchiveBucket(bucketId) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      yield this.bucketManager.unarchiveBucket(bucketId);
    });
  }
  getBucketUploadCount(bucketId) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.getBucketUploadCount(bucketId);
    });
  }
  getBucketUploads(bucketId, options) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.getBucketUploads(bucketId, options);
    });
  }
  getUpload(uploadId) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.getUpload(uploadId);
    });
  }
  pinUpload(uploadId) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.pinUpload(uploadId);
    });
  }
  unpinUpload(uploadId) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.unpinUpload(uploadId);
    });
  }
  getOrganizationUsage(organizationId) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u;
      yield this.validateStorageOrganizationType();
      const usage = yield this.spheronApi.getOrganizationUsage(
        organizationId,
        "storage"
      );
      return {
        used: {
          bandwidth: (_a = usage.usedBandwidth) != null ? _a : 0,
          storageArweave: (_b = usage.usedStorageArweave) != null ? _b : 0,
          storageIPFS: (_c = usage.usedStorageIPFS) != null ? _c : 0,
          storageFilecoin: (_d = usage.usedStorageFilecoin) != null ? _d : 0,
          domains: (_e = usage.usedDomains) != null ? _e : 0,
          hnsDomains: (_f = usage.usedHnsDomains) != null ? _f : 0,
          ensDomains: (_g = usage.usedEnsDomains) != null ? _g : 0,
          numberOfRequests: (_h = usage.usedNumberOfRequests) != null ? _h : 0,
          parallelUploads: (_i = usage.usedParallelUploads) != null ? _i : 0,
          imageOptimization: (_j = usage.usedImageOptimizations) != null ? _j : 0,
          ipfsBandwidth: (_k = usage.usedIpfsBandwidth) != null ? _k : 0,
          ipfsNumberOfRequests: (_l = usage.usedIpfsNumberOfRequests) != null ? _l : 0
        },
        limit: {
          bandwidth: (_m = usage.bandwidthLimit) != null ? _m : 0,
          storageArweave: (_n = usage.storageArweaveLimit) != null ? _n : 0,
          storageIPFS: (_o = usage.storageIPFSLimit) != null ? _o : 0,
          domains: (_p = usage.domainsLimit) != null ? _p : 0,
          hnsDomains: (_q = usage.usedHnsDomains) != null ? _q : 0,
          ensDomains: (_r = usage.usedEnsDomains) != null ? _r : 0,
          parallelUploads: (_s = usage.parallelUploadsLimit) != null ? _s : 0,
          imageOptimization: (_t = usage.imageOptimizationsLimit) != null ? _t : 0,
          ipfsBandwidth: (_u = usage.ipfsBandwidthLimit) != null ? _u : 0
        }
      };
    });
  }
  getTokenScope() {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.getScopeFromToken();
    });
  }
  getBucketIpnsRecords(bucketId) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.getBucketIpnsRecords(bucketId);
    });
  }
  getBucketIpnsRecord(bucketId, ipnsRecordId) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.getBucketIpnsRecord(bucketId, ipnsRecordId);
    });
  }
  addBucketIpnsRecord(bucketId, uploadId) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.addBucketIpnsRecord(bucketId, uploadId);
    });
  }
  updateBucketIpnsRecord(bucketId, ipnsRecordId, uploadId) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.bucketManager.updateBucketIpnsRecord(
        bucketId,
        ipnsRecordId,
        uploadId
      );
    });
  }
  deleteBucketIpnsRecord(bucketId, ipnsRecordId) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      yield this.spheronApi.deleteBucketIpnsRecord(bucketId, ipnsRecordId);
    });
  }
  migrateStaticSiteOrgToStorage(staticSiteOrganizationId, storageOrganizationId) {
    return __async(this, null, function* () {
      yield this.validateStorageOrganizationType();
      return yield this.spheronApi.migrateStaticSiteOrgToStorage(
        staticSiteOrganizationId,
        storageOrganizationId
      );
    });
  }
  validateStorageOrganizationType() {
    return __async(this, null, function* () {
      const type = yield this.getOrganizationTypeFromToken();
      if (type != import_core3.AppTypeEnum.STORAGE) {
        throw new Error(
          "The token used won't work with version >2.0.0 of SDK, please create a new token from your storage organisation."
        );
      }
    });
  }
};
var src_default = SpheronClient;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BucketStateEnum,
  DomainTypeEnum,
  ProtocolEnum,
  SpheronClient,
  TokenScope,
  UploadStatusEnum,
  ipfs,
  uint8arrayToString
});
